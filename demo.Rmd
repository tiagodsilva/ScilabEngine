---
title: "file" 
author: "você" 
output: html_document
---

```{r, eval=TRUE, include=FALSE} 
library(stringr) 
eng_scilab <- function(options) { 
code <- str_c(options$code, collapse = "\n")  
if (options$eval) { 
flags = "--timeout 4s -ns -e" 
if(!is.null(options$timeout)) flags = paste("--timeout", options$timeout, "-ns -e") 
if(typeof(options$scilab_file) == "character") {
  exec_file <- sprintf("exec('%s', -1)", options$scilab_file) 
  code <- paste(exec_file, "\n", code)   
} 

if(!is.null(options$scilab_var)) {
  code <- paste(options$scilab_var, code) 
} 
# print(code) 
code <- paste(code, "\nexit") 
code <- paste("try;", code, ";catch;", 
              "disp('some exception was raised! :(') 
              disp('this is the exception:') 
              disp(lasterror())  
              exit; end") 
cmd <- sprintf('scilab-cli %s %s',
             flags, shQuote(code, type="sh")) 

# options$comment = NA 
out <- system(cmd, intern = TRUE) 
# print(out) 
}else{out <- ""}

knitr::engine_output(options, options$code, out)

}

knitr::knit_engines$set(scilab=eng_scilab) 
``` 

# Scilab em RMarkdown 
Código Scilab em RMarkdown. 

Você pode escrever uma função (que não será executada; `eval=FALSE`): 

```{r basel, engine="scilab", eval=FALSE} 
function [x] = id(n) 
  x = n 
endfunction 
``` 

Em seguida, você pode inserir o arquivo em que essa função está e executá-la. 
```{r function, engine="scilab", scilab_file = "HelloWorld.sci"} 
x = id(2) 
``` 

As variáveis não são recicláveis entre chunks. Você pode defini-las em `options$scilab_var`. 
```{r babel, engine ="scilab", scilab_var = "x = 3; y = 2;"} 
x + y 
``` 
Você pode chamar uma função e definir variáveis também: 
```{r matrix, engine="scilab", scilab_file = "HelloWorld.sci", scilab_var = "x = 3; y = 2;"} 
id(x) + id(y)  
``` 


E Latex: 
$$ 
  \begin{bmatrix} 
    1 & 2 \\ 
    3 & 4 \\ 
  \end{bmatrix} 
$$ 

